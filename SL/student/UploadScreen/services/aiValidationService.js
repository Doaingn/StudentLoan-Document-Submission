import {
  collection,
  addDoc,
  doc,
  getDoc,
  updateDoc,
  query,
  where,
  getDocs,
  deleteDoc,
  orderBy,
  limitToLast,
} from "firebase/firestore";
import { db, auth } from "../../../database/firebase";
import {
  validateDocument,
  showValidationAlert,
  checkAIBackendStatus,
  needsAIValidation,
} from "../documents_ai/UnifiedDocumentAI";

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏à‡∏¥‡∏ï‡∏≠‡∏≤‡∏™‡∏≤‡∏•‡∏á Firebase
export const saveVolunteerHoursToFirebase = async (totalHours, appConfig) => {
  try {
    const currentUser = auth.currentUser;
    if (!currentUser) {
      console.error("No authenticated user found");
      return false;
    }

    const userRef = doc(db, "users", currentUser.uid);
    await updateDoc(userRef, {
      volunteerHours: totalHours,
      volunteerHoursUpdatedAt: new Date().toISOString(),
      academicYear: appConfig?.academicYear || null,
      term: appConfig?.term || null,
    });

    console.log(`‚úÖ Volunteer hours saved to Firebase: ${totalHours} hours`);
    return true;
  } catch (error) {
    console.error("‚ùå Error saving volunteer hours to Firebase:", error);
    return false;
  }
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ã‡πâ‡∏≥
export const checkDuplicateVolunteerFile = async (file, existingFiles) => {
  try {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏•‡∏∞‡∏Ç‡∏ô‡∏≤‡∏î
    const isDuplicate = existingFiles.some(
      (existingFile) =>
        existingFile.filename === file.filename &&
        existingFile.size === file.size
    );

    if (isDuplicate) {
      console.log("‚ùå Duplicate file detected:", file.filename);
      return true;
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≤‡∏Å content hash (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°)
    const FileSystem = await import("expo-file-system/legacy");
    const fileInfo = await FileSystem.getInfoAsync(file.uri);

    if (fileInfo.exists) {
      // ‡∏™‡∏£‡πâ‡∏≤‡∏á hash ‡∏à‡∏≤‡∏Å URI ‡πÅ‡∏•‡∏∞‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå (‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢)
      const fileHash = `${file.uri}_${file.size}`;

      const contentDuplicate = existingFiles.some((existingFile) => {
        const existingHash = `${existingFile.uri}_${existingFile.size}`;
        return existingHash === fileHash;
      });

      return contentDuplicate;
    }

    return false;
  } catch (error) {
    console.error("Error checking duplicate file:", error);
    return false;
  }
};

// Save AI validation result to Firebase
export const saveAIValidationResult = async (validationData) => {
  try {
    const currentUser = auth.currentUser;
    if (!currentUser) {
      console.error("No authenticated user found");
      return null;
    }

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á validation result object
    const validationResult = {
      userId: currentUser.uid,
      userEmail: currentUser.email,
      documentType: validationData.documentType,
      fileName: validationData.fileName,
      fileUri: validationData.fileUri,
      mimeType: validationData.mimeType,
      validatedAt: new Date().toISOString(),

      // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö AI
      aiResult: {
        isValid: validationData.aiResult.isValid || false,
        confidence: validationData.aiResult.confidence || 0,
        overall_status: validationData.aiResult.overall_status || "unknown",

        // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÅ‡∏¢‡∏Å‡∏≠‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£
        extractedData: validationData.aiResult.extractedData || {},

        // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏£‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏ô‡∏≤ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ID Card)
        certificationInfo: validationData.aiResult.certificationInfo || {},

        // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£
        imageQuality: validationData.aiResult.imageQuality || "unknown",

        // ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ó‡∏µ‡πà‡∏û‡∏ö
        qualityIssues: validationData.aiResult.qualityIssues || [],

        // ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥
        recommendations: validationData.aiResult.recommendations || [],

        // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£
        documentSpecificData:
          validationData.aiResult.documentSpecificData || {},

        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏à‡∏¥‡∏ï‡∏≠‡∏≤‡∏™‡∏≤
        ...(validationData.documentType === "volunteer_doc" && {
          accumulatedHours: validationData.aiResult.accumulatedHours || 0,
          volunteerActivities:
            validationData.aiResult.volunteerActivities || [],
        }),

        // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• AI backend ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ
        aiBackendInfo: {
          method: validationData.aiBackendInfo?.method || "unknown",
          model: validationData.aiBackendInfo?.model || "unknown",
          backendUrl: validationData.aiBackendInfo?.backendUrl || null,
        },
      },

      // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• academic context
      academicYear: validationData.academicYear || null,
      term: validationData.term || null,

      // ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
      userAction: "accepted",

      // Metadata
      metadata: {
        appVersion: "1.0.0",
        platform: "react-native",
        validationTimestamp: Date.now(),
      },
    };

    // ‡πÄ‡∏Å‡πá‡∏ö‡∏•‡∏á‡πÉ‡∏ô collection "ai_validation_results"
    const validationRef = await addDoc(
      collection(db, "ai_validation_results"),
      validationResult
    );

    console.log("‚úÖ AI validation result saved with ID:", validationRef.id);

    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£ user ‡∏î‡πâ‡∏ß‡∏¢ (‡πÄ‡∏Å‡πá‡∏ö reference)
    const userRef = doc(db, "users", currentUser.uid);
    const userDoc = await getDoc(userRef);

    if (userDoc.exists()) {
      const userData = userDoc.data();
      const aiValidations = userData.aiValidations || [];

      // ‡πÄ‡∏û‡∏¥‡πà‡∏° reference ‡πÉ‡∏´‡∏°‡πà
      aiValidations.push({
        validationId: validationRef.id,
        documentType: validationData.documentType,
        fileName: validationData.fileName,
        validatedAt: new Date().toISOString(),
        status: validationData.aiResult.overall_status,
      });

      // ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞ 50 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£ user ‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
      if (aiValidations.length > 50) {
        aiValidations.splice(0, aiValidations.length - 50);
      }

      await updateDoc(userRef, {
        aiValidations: aiValidations,
        lastAIValidation: new Date().toISOString(),
      });
    }

    return validationRef.id;
  } catch (error) {
    console.error("‚ùå Error saving AI validation result:", error);
    return null;
  }
};

// Clean up AI validation data when file is removed
export const cleanupAIValidationData = async (fileToRemove, docId) => {
  try {
    const currentUser = auth.currentUser;
    if (!currentUser) {
      console.warn("No authenticated user found for AI data cleanup");
      return;
    }

    console.log(
      `üßπ Cleaning up AI validation data for file: ${fileToRemove.filename}`
    );

    // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å ai_validation_results collection
    const validationsRef = collection(db, "ai_validation_results");

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ validation results ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ
    const q = query(
      validationsRef,
      where("userId", "==", currentUser.uid),
      where("documentType", "==", docId),
      where("fileName", "==", fileToRemove.filename || `${docId}_file`)
    );

    const querySnapshot = await getDocs(q);
    const deletionPromises = [];

    querySnapshot.forEach((docSnapshot) => {
      console.log(`üóëÔ∏è Deleting AI validation result: ${docSnapshot.id}`);
      deletionPromises.push(deleteDoc(docSnapshot.ref));
    });

    // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• validation results ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á
    await Promise.all(deletionPromises);

    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• aiValidations ‡πÉ‡∏ô user document
    const userRef = doc(db, "users", currentUser.uid);
    const userDoc = await getDoc(userRef);

    if (userDoc.exists()) {
      const userData = userDoc.data();
      const aiValidations = userData.aiValidations || [];

      // ‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏•‡∏ö‡∏≠‡∏≠‡∏Å
      const updatedAiValidations = aiValidations.filter((validation) => {
        return !(
          validation.documentType === docId &&
          validation.fileName === (fileToRemove.filename || `${docId}_file`)
        );
      });

      // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï user document
      await updateDoc(userRef, {
        aiValidations: updatedAiValidations,
      });

      console.log(
        `‚úÖ Cleaned up ${
          aiValidations.length - updatedAiValidations.length
        } AI validation entries from user document`
      );
    }

    console.log(
      `‚úÖ AI validation data cleanup completed for ${fileToRemove.filename}`
    );
  } catch (error) {
    console.error("‚ùå Error cleaning up AI validation data:", error);
  }
};

// Perform AI validation with user interaction
export const performAIValidation = async (
  file,
  docId,
  volunteerHours,
  setVolunteerHours,
  appConfig,
  uploads,
  setIsValidatingAI
) => {
  const aiBackendAvailable = await checkAIBackendStatus();

  if (!aiBackendAvailable) {
    throw new Error("‡∏£‡∏∞‡∏ö‡∏ö AI ‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô");
  }

  if (!needsAIValidation(docId)) {
    console.log(`Document ${docId} does not need AI validation`);
    return true;
  }

  try {
    console.log(`ü§ñ Starting AI validation for ${docId}`);

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ã‡πâ‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏à‡∏¥‡∏ï‡∏≠‡∏≤‡∏™‡∏≤
    if (docId === "volunteer_doc") {
      const existingFiles = uploads[docId] || [];
      const isDuplicate = await checkDuplicateVolunteerFile(
        file,
        existingFiles
      );

      if (isDuplicate) {
        const Alert = require("react-native").Alert;
        Alert.alert(
          "‡πÑ‡∏ü‡∏•‡πå‡∏ã‡πâ‡∏≥",
          "‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏∑‡πà‡∏ô",
          [{ text: "‡∏ï‡∏Å‡∏•‡∏á" }]
        );
        return false;
      }
    }

    const validationResult = await validateDocument(
      file.uri,
      docId,
      null,
      file.mimeType
    );

    // ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    const validationDataForDB = {
      documentType: docId,
      fileName: file.filename || `${docId}_file`,
      fileUri: file.uri,
      mimeType: file.mimeType,
      aiResult: validationResult,
      academicYear: appConfig?.academicYear || null,
      term: appConfig?.term || null,
      aiBackendInfo: {
        method: aiBackendAvailable ? "available" : "unavailable",
      },
    };

    if (docId === "volunteer_doc") {
      const hours = validationResult.accumulatedHours || 0;
      console.log(`üìä Extracted volunteer hours: ${hours}`);

      return new Promise((resolve) => {
        const newTotal = volunteerHours + hours;

        const Alert = require("react-native").Alert;
        Alert.alert(
          "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏à‡∏¥‡∏ï‡∏≠‡∏≤‡∏™‡∏≤",
          `AI ‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö ${hours} ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏à‡∏¥‡∏ï‡∏≠‡∏≤‡∏™‡∏≤‡πÉ‡∏ô‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏ô‡∏µ‡πâ\n‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏£‡∏ß‡∏°‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: ${newTotal} ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á`,
          [
            {
              text: "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å",
              style: "cancel",
              onPress: () => {
                console.log("‚úó User cancelled volunteer document");
                resolve(false);
              },
            },
            {
              text: "‡πÉ‡∏ä‡πâ‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ",
              onPress: async () => {
                console.log("‚úì User accepted volunteer document");

                try {
                  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏à‡∏¥‡∏ï‡∏≠‡∏≤‡∏™‡∏≤‡πÉ‡∏ô state
                  setVolunteerHours(newTotal);

                  // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏à‡∏¥‡∏ï‡∏≠‡∏≤‡∏™‡∏≤‡∏•‡∏á Firebase
                  await saveVolunteerHoursToFirebase(newTotal, appConfig);

                  // ‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö AI ‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                  await saveAIValidationResult(validationDataForDB);

                  // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ hours ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå
                  file.hours = hours;

                  if (newTotal >= 36) {
                    Alert.alert(
                      "‡∏Ñ‡∏£‡∏ö‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏à‡∏¥‡∏ï‡∏≠‡∏≤‡∏™‡∏≤‡πÅ‡∏•‡πâ‡∏ß",
                      `‡∏Ñ‡∏∏‡∏ì‡∏™‡∏∞‡∏™‡∏°‡∏Ñ‡∏£‡∏ö ${newTotal} ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á`
                    );
                  }

                  console.log("‚úÖ Volunteer document accepted successfully");
                  resolve(true);

                } catch (error) {
                  console.error(
                    "Error in volunteer document acceptance:",
                    error
                  );

                  Alert.alert(
                    "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
                    "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà"
                  );
                  resolve(false);
                } finally {
                  // ‚úÖ ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå state ‡πÄ‡∏™‡∏°‡∏≠
                  setIsValidatingAI((prev) => {
                    const newState = { ...prev };
                    delete newState[docId];
                    return newState;
                  });
                }
              },
            },
          ],
          { cancelable: false }
        );
      });
    }

    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏≠‡∏∑‡πà‡∏ô‡πÜ
    return new Promise((resolve) => {
      showValidationAlert(
        validationResult,
        docId,
        async () => {
          console.log(`‚úì AI Validation passed for ${file.filename} (${docId})`);

          try {
            // ‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö AI ‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
            await saveAIValidationResult(validationDataForDB);

            console.log("‚úÖ Validation accepted successfully");
            resolve(true);
          } catch (error) {
            console.error("Error saving validation result:", error);
            resolve(true); // ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á resolve true ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ validation ‡∏ú‡πà‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß
          }
        },
        () => {
          console.log(`‚úó AI Validation failed for ${file.filename} (${docId})`);
          resolve(false);
        }
      );
    });
  } catch (error) {
    console.error("AI validation error:", error);
    throw error;
  }
};
// Get user AI validation history
export const getUserAIValidationHistory = async (userId, limit = 20) => {
  try {
    const validationsRef = collection(db, "ai_validation_results");
    const q = query(
      validationsRef,
      where("userId", "==", userId),
      orderBy("validatedAt", "desc"),
      limitToLast(limit)
    );

    const querySnapshot = await getDocs(q);
    const validations = [];

    querySnapshot.forEach((doc) => {
      validations.push({
        id: doc.id,
        ...doc.data(),
      });
    });

    return validations;
  } catch (error) {
    console.error("Error fetching AI validation history:", error);
    return [];
  }
};

export {
  validateDocument,
  showValidationAlert,
  checkAIBackendStatus,
  needsAIValidation,
};
